from django.db import models
from django.conf import settings
import json # For stat stages
import random # For initial turn
from .logic import constants # <-- Import local constants

# --- NEW: Script Model ---
class Script(models.Model):
    name = models.CharField(max_length=100, unique=True, help_text="Unique name for identifying the script in admin.")
    description = models.TextField(blank=True, help_text="Optional description of what the script does.")
    lua_code = models.TextField("Lua Code", help_text="The actual Lua script content.")
    
    # --- Link back to the Attack --- 
    attack = models.ForeignKey(
        'Attack', 
        related_name='scripts', # Attack can access its scripts via attack.scripts.all()
        on_delete=models.CASCADE, 
        help_text="The Attack this script is associated with."
    )
    
    # --- Trigger Points --- 
    trigger_on_attack = models.BooleanField(
        "Trigger On Attack Use?", default=False, 
        help_text="Runs once immediately when the associated Attack is used."
    )
    trigger_before_attacker_turn = models.BooleanField(
        "Trigger Before Attacker Turn?", default=False, 
        help_text="If persistent, runs before the original attacker takes their turn."
    )
    trigger_after_attacker_turn = models.BooleanField(
        "Trigger After Attacker Turn?", default=False, 
        help_text="If persistent, runs after the original attacker finishes their turn."
    )
    trigger_before_target_turn = models.BooleanField(
        "Trigger Before Target Turn?", default=False, 
        help_text="If persistent, runs before the original target takes their turn."
    )
    trigger_after_target_turn = models.BooleanField(
        "Trigger After Target Turn?", default=False, 
        help_text="If persistent, runs after the original target finishes their turn."
    )
    
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self):
        return self.name
# --- END Script Model ---


class Attack(models.Model):
    name = models.CharField(max_length=50, unique=True)
    description = models.TextField(blank=True)
    emoji = models.CharField(max_length=5, blank=True, null=True, help_text="Optional emoji icon for the attack")
    momentum_cost = models.PositiveIntegerField(default=1, help_text="Base momentum generated by using this attack")
    

    turn_number = models.IntegerField(default=1)
    
    def __str__(self):
        return self.name

class Battle(models.Model):
    STATUS_CHOICES = [
        ('pending', 'Pending'),
        ('active', 'Active'),
        ('finished', 'Finished'),
        ('declined', 'Declined'),
    ]
    TURN_CHOICES = [
        ('player1', 'Player 1'),
        ('player2', 'Player 2'),
    ]

    player1 = models.ForeignKey(settings.AUTH_USER_MODEL, related_name='battles_as_player1', on_delete=models.CASCADE)
    player2 = models.ForeignKey(settings.AUTH_USER_MODEL, related_name='battles_as_player2', on_delete=models.CASCADE)
    status = models.CharField(max_length=10, choices=STATUS_CHOICES, default='pending')
    winner = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.SET_NULL, null=True, blank=True, related_name='battles_won')

    # Game state fields
    current_hp_player1 = models.IntegerField(default=100)
    current_hp_player2 = models.IntegerField(default=100)
    # Use JSONField for stat stages, initialized as empty dict
    stat_stages_player1 = models.JSONField(default=dict)
    stat_stages_player2 = models.JSONField(default=dict)
    custom_statuses_player1 = models.JSONField(default=dict)
    custom_statuses_player2 = models.JSONField(default=dict)
    registered_scripts = models.JSONField(default=list) # Stores active script instances
    last_turn_summary = models.JSONField(default=list) # Log of actions/effects from the LAST turn

    # --- Momentum and Turn --- 
    current_momentum_player1 = models.IntegerField(default=0) 
    current_momentum_player2 = models.IntegerField(default=0)
    whose_turn = models.CharField(max_length=10, choices=[('player1', 'Player 1'), ('player2', 'Player 2')], blank=True, null=True) # Can be null initially
    turn_number = models.IntegerField(default=1)
    
    # ADDED BACK: Store attacks selected specifically for this battle
    battle_attacks_player1 = models.ManyToManyField(
        'Attack',
        related_name='battles_as_player1_attack',
        through='BattlePlayer1AttackSelection',
        blank=True
    )
    battle_attacks_player2 = models.ManyToManyField(
        'Attack',
        related_name='battles_as_player2_attack',
        through='BattlePlayer2AttackSelection',
        blank=True
    )

    # Timestamping
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def initialize_battle_state(self):
        """Sets initial HP based on players and determines starting turn."""
        if self.player1:
            self.current_hp_player1 = self.player1.hp
            # Copy player1's selected attacks to the battle-specific field
            self.battle_attacks_player1.set(self.player1.selected_attacks.all())
        if self.player2:
            self.current_hp_player2 = self.player2.hp
            # Copy player2's selected attacks to the battle-specific field
            self.battle_attacks_player2.set(self.player2.selected_attacks.all())
        
        self.stat_stages_player1 = {}
        self.stat_stages_player2 = {}
        self.custom_statuses_player1 = {}
        self.custom_statuses_player2 = {}
        self.registered_scripts = []
        self.last_turn_summary = []
        self.current_momentum_player1 = settings.BASE_MOMENTUM
        self.current_momentum_player2 = settings.BASE_MOMENTUM
        self.turn_number = 1

        # Simple turn determination: Player 1 starts? Or random?
        self.whose_turn = 'player1' # Player 1 starts by default
        self.save() # Save the initialized state

    def get_player_role(self, user):
        """Returns 'player1' or 'player2' if the user is in this battle, else None."""
        if user == self.player1:
            return 'player1'
        elif user == self.player2:
            return 'player2'
        return None

    # Resolve turn logic will be in battle_logic.py, but could be called from here
    # def resolve_turn(self):
    #     from .battle_logic import resolve_battle_turn # Avoid circular import
    #     resolve_battle_turn(self)

# --- Through Models for Battle Attacks --- 
class BattlePlayer1AttackSelection(models.Model):
    battle = models.ForeignKey(Battle, on_delete=models.CASCADE)
    attack = models.ForeignKey(Attack, on_delete=models.CASCADE)
    # Add any extra fields if needed, e.g., usage count
    class Meta:
        unique_together = ('battle', 'attack')

class BattlePlayer2AttackSelection(models.Model):
    battle = models.ForeignKey(Battle, on_delete=models.CASCADE)
    attack = models.ForeignKey(Attack, on_delete=models.CASCADE)
    class Meta:
        unique_together = ('battle', 'attack')