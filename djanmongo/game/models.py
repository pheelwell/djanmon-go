from django.db import models
from django.conf import settings
import json # For stat stages
import random # For initial turn

class Attack(models.Model):
    TARGET_CHOICES = [
        ('self', 'Self'),
        ('enemy', 'Enemy'),
    ]
    STAT_CHOICES = [
        ('ATK', 'Attack'),
        ('DEF', 'Defense'),
        ('SPEED', 'Speed'),
        ('HP', 'HP'), # Note: HP modification is primarily via hp_amount
        ('NONE', 'None'), # For attacks that don't target stats
    ]

    name = models.CharField(max_length=50, unique=True)
    description = models.TextField(blank=True)
    power = models.PositiveIntegerField(default=0, help_text="Base power of the attack (0 for non-damaging moves)")
    target = models.CharField(max_length=5, choices=TARGET_CHOICES, default='enemy')
    hp_amount = models.IntegerField(default=0, help_text="Direct HP change (e.g., healing, recoil). Usually 0 for damaging moves.")
    target_stat = models.CharField(max_length=5, choices=STAT_CHOICES, default='NONE')
    stat_mod = models.IntegerField(default=0, help_text="Number of stages to modify stat (+/-)")
    emoji = models.CharField(max_length=5, blank=True, null=True, help_text="Optional emoji icon for the attack")
    momentum_cost = models.PositiveIntegerField(default=1, help_text="Momentum generated by using this attack")
    # Add accuracy later if needed

    def __str__(self):
        return self.name

class Battle(models.Model):
    STATUS_CHOICES = [
        ('pending', 'Pending'),
        ('active', 'Active'),
        ('finished', 'Finished'),
        ('declined', 'Declined'),
    ]
    TURN_CHOICES = [
        ('player1', 'Player 1'),
        ('player2', 'Player 2'),
    ]

    player1 = models.ForeignKey(settings.AUTH_USER_MODEL, related_name='battles_as_player1', on_delete=models.CASCADE)
    player2 = models.ForeignKey(settings.AUTH_USER_MODEL, related_name='battles_as_player2', on_delete=models.CASCADE)
    status = models.CharField(max_length=10, choices=STATUS_CHOICES, default='pending')
    winner = models.ForeignKey(settings.AUTH_USER_MODEL, related_name='won_battles', null=True, blank=True, on_delete=models.SET_NULL)

    # --- Battle State ---
    current_hp_player1 = models.IntegerField(null=True, blank=True)
    current_hp_player2 = models.IntegerField(null=True, blank=True)
    stat_stages_player1 = models.JSONField(default=dict)
    stat_stages_player2 = models.JSONField(default=dict)
    last_turn_summary = models.JSONField(default=list, blank=True)
    
    # --- Momentum State (NEW) ---
    current_momentum_player1 = models.IntegerField(default=0)
    current_momentum_player2 = models.IntegerField(default=0)
    whose_turn = models.CharField(max_length=10, choices=TURN_CHOICES, default='player1')

    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self):
        return f"Battle {self.id}: {self.player1.username} vs {self.player2.username} ({self.status})"

    def initialize_battle_state(self):
        """Sets initial HP, stat stages, momentum, and turn when battle becomes active."""
        if self.status == 'active':
            self.current_hp_player1 = self.player1.hp
            self.current_hp_player2 = self.player2.hp
            self.stat_stages_player1 = {'attack': 0, 'defense': 0, 'speed': 0}
            self.stat_stages_player2 = {'attack': 0, 'defense': 0, 'speed': 0}
            self.last_turn_summary = []
            # Initialize Momentum
            self.current_momentum_player1 = 0
            self.current_momentum_player2 = 0
            # Randomly choose starting player (or default to P1)
            self.whose_turn = random.choice(['player1', 'player2']) 
            self.save()

    def get_player_role(self, user):
        """Returns 'player1' or 'player2' if the user is in this battle, else None."""
        if user == self.player1:
            return 'player1'
        elif user == self.player2:
            return 'player2'
        return None

    # Resolve turn logic will be in battle_logic.py, but could be called from here
    # def resolve_turn(self):
    #     from .battle_logic import resolve_battle_turn # Avoid circular import
    #     resolve_battle_turn(self)