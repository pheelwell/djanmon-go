from django.db import models
from django.conf import settings
import json # For stat stages
import random # For initial turn

class Attack(models.Model):
    name = models.CharField(max_length=50, unique=True)
    description = models.TextField(blank=True)
    emoji = models.CharField(max_length=5, blank=True, null=True, help_text="Optional emoji icon for the attack")
    momentum_cost = models.PositiveIntegerField(default=1, help_text="Base momentum generated by using this attack")
    
    # --- Lua Script Hooks --- 
    lua_script_on_attack = models.TextField(
        "On Attack Script",
        blank=True, 
        null=True, 
        help_text=(
            "Lua script executed when this attack is used."
            " Use API funcs like apply_std_damage(pwr), apply_std_hp_change(amt), apply_std_stat_change(stat, mod), etc."
        )
    )
    lua_script_before_opponent = models.TextField(
        "Before Opponent Attacks Script",
        blank=True, 
        null=True, 
        help_text="Lua script to potentially register. Runs before the opponent makes their next move."
    )
    lua_script_after_opponent = models.TextField(
        "After Opponent Attacks Script",
        blank=True, 
        null=True, 
        help_text="Lua script to potentially register. Runs after the opponent finishes their next move."
    )
    
    # --- Script Registration Toggles --- 
    register_before_opponent = models.BooleanField(
        "Register 'Before Opponent' Script?", 
        default=False, 
        help_text="If checked, the 'Before Opponent Attacks Script' will be registered to run on future opponent turns when this attack is used."
    )
    register_after_opponent = models.BooleanField(
        "Register 'After Opponent' Script?",
        default=False,
        help_text="If checked, the 'After Opponent Attacks Script' will be registered to run on future opponent turns when this attack is used."
    )

    def __str__(self):
        return self.name

class Battle(models.Model):
    STATUS_CHOICES = [
        ('pending', 'Pending'),
        ('active', 'Active'),
        ('finished', 'Finished'),
        ('declined', 'Declined'),
    ]
    TURN_CHOICES = [
        ('player1', 'Player 1'),
        ('player2', 'Player 2'),
    ]

    player1 = models.ForeignKey(settings.AUTH_USER_MODEL, related_name='battles_as_player1', on_delete=models.CASCADE)
    player2 = models.ForeignKey(settings.AUTH_USER_MODEL, related_name='battles_as_player2', on_delete=models.CASCADE)
    status = models.CharField(max_length=10, choices=STATUS_CHOICES, default='pending')
    winner = models.ForeignKey(settings.AUTH_USER_MODEL, related_name='won_battles', null=True, blank=True, on_delete=models.SET_NULL)

    # --- Battle State ---
    current_hp_player1 = models.IntegerField(null=True, blank=True)
    current_hp_player2 = models.IntegerField(null=True, blank=True)
    stat_stages_player1 = models.JSONField(default=dict)
    stat_stages_player2 = models.JSONField(default=dict)
    last_turn_summary = models.JSONField(default=list, blank=True)
    
    # --- Momentum State (NEW) ---
    current_momentum_player1 = models.IntegerField(default=0)
    current_momentum_player2 = models.IntegerField(default=0)
    whose_turn = models.CharField(max_length=10, choices=TURN_CHOICES, default='player1')
    turn_number = models.PositiveIntegerField(default=0, help_text="Current turn number, starts at 1.")

    # --- NEW: Registered Lua Scripts ---
    # Stores list of dicts: {"type": "before"/"after", "script": "...", "source_attack_id": id}
    registered_scripts = models.JSONField(default=list, blank=True)

    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self):
        return f"Battle {self.id}: {self.player1.username} vs {self.player2.username} ({self.status})"

    def initialize_battle_state(self):
        """Sets initial HP, stat stages, momentum, and turn when battle becomes active."""
        if self.status == 'active':
            self.current_hp_player1 = self.player1.hp
            self.current_hp_player2 = self.player2.hp
            self.stat_stages_player1 = {'attack': 0, 'defense': 0, 'speed': 0}
            self.stat_stages_player2 = {'attack': 0, 'defense': 0, 'speed': 0}
            self.last_turn_summary = []
            # Initialize Momentum
            self.current_momentum_player1 = 0
            self.current_momentum_player2 = 0
            # Randomly choose starting player (or default to P1)
            self.whose_turn = random.choice(['player1', 'player2']) 
            self.turn_number = 1 # Start at turn 1
            self.save()

    def get_player_role(self, user):
        """Returns 'player1' or 'player2' if the user is in this battle, else None."""
        if user == self.player1:
            return 'player1'
        elif user == self.player2:
            return 'player2'
        return None

    # Resolve turn logic will be in battle_logic.py, but could be called from here
    # def resolve_turn(self):
    #     from .battle_logic import resolve_battle_turn # Avoid circular import
    #     resolve_battle_turn(self)