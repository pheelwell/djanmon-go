# Generated by Django 5.1.7 on 2025-04-26 15:47

from django.db import migrations, models


# --- Data Migration Function ---
def forwards_func(apps, schema_editor):
    Script = apps.get_model('game', 'Script')
    db_alias = schema_editor.connection.alias
    print("\nApplying data migration for Script trigger system...")
    scripts_to_update = []
    for script in Script.objects.using(db_alias).all():
        updated = False
        # Determine new values based on old booleans
        if script.trigger_on_attack_old:
            script.trigger_who = 'ME'
            script.trigger_when = 'ON_USE'
            script.trigger_duration = 'ONCE'
            updated = True
        elif script.trigger_before_attacker_turn_old:
            script.trigger_who = 'ME'
            script.trigger_when = 'BEFORE_TURN'
            script.trigger_duration = 'PERSISTENT'
            updated = True
        elif script.trigger_after_attacker_turn_old:
            script.trigger_who = 'ME'
            script.trigger_when = 'AFTER_TURN'
            script.trigger_duration = 'PERSISTENT'
            updated = True
        elif script.trigger_before_target_turn_old:
            script.trigger_who = 'ENEMY'
            script.trigger_when = 'BEFORE_TURN'
            script.trigger_duration = 'PERSISTENT'
            updated = True
        elif script.trigger_after_target_turn_old:
            script.trigger_who = 'ENEMY'
            script.trigger_when = 'AFTER_TURN'
            script.trigger_duration = 'PERSISTENT'
            updated = True
        else:
            # Default case if no old trigger was set (shouldn't happen often)
            # Set to a sensible default, maybe AFTER_TURN PERSISTENT on ENEMY?
            script.trigger_who = 'ENEMY'
            script.trigger_when = 'AFTER_TURN'
            script.trigger_duration = 'PERSISTENT'
            print(f"  Script ID {script.id} ({script.name}) had no old triggers set, applying default.")
            updated = True # Mark as updated to ensure it's saved

        if updated:
            scripts_to_update.append(script)

    if scripts_to_update:
        # Bulk update is generally faster
        Script.objects.using(db_alias).bulk_update(
            scripts_to_update,
            ['trigger_who', 'trigger_when', 'trigger_duration']
        )
        print(f"  Successfully migrated trigger data for {len(scripts_to_update)} scripts.")
    else:
        print("  No scripts needed data migration for triggers.")

def reverse_func(apps, schema_editor):
    # This reverse function attempts to map back, but it's lossy
    # as multiple new states could map back to one old state.
    Script = apps.get_model('game', 'Script')
    db_alias = schema_editor.connection.alias
    print("\nReversing data migration for Script trigger system (best effort)...")
    scripts_to_update = []
    for script in Script.objects.using(db_alias).all():
        script.trigger_on_attack_old = False
        script.trigger_before_attacker_turn_old = False
        script.trigger_after_attacker_turn_old = False
        script.trigger_before_target_turn_old = False
        script.trigger_after_target_turn_old = False

        if script.trigger_who == 'ME' and script.trigger_when == 'ON_USE':
            script.trigger_on_attack_old = True
        elif script.trigger_who == 'ME' and script.trigger_when == 'BEFORE_TURN':
            script.trigger_before_attacker_turn_old = True
        elif script.trigger_who == 'ME' and script.trigger_when == 'AFTER_TURN':
            script.trigger_after_attacker_turn_old = True
        elif script.trigger_who == 'ENEMY' and script.trigger_when == 'BEFORE_TURN':
            script.trigger_before_target_turn_old = True
        elif script.trigger_who == 'ENEMY' and script.trigger_when == 'AFTER_TURN':
            script.trigger_after_target_turn_old = True
        # Other combinations cannot be reliably mapped back to a single old field

        scripts_to_update.append(script)

    if scripts_to_update:
        Script.objects.using(db_alias).bulk_update(
            scripts_to_update,
            ['trigger_on_attack_old', 'trigger_before_attacker_turn_old', 'trigger_after_attacker_turn_old', 'trigger_before_target_turn_old', 'trigger_after_target_turn_old']
        )
        print(f"  Attempted to reverse trigger data for {len(scripts_to_update)} scripts.")
    else:
        print("  No scripts found for reverse migration.")
# --- End Data Migration Function ---

class Migration(migrations.Migration):

    dependencies = [
        ('game', '0029_remove_attackusagestats_wins_contributed_and_more'),
    ]

    operations = [
        # 1. Rename old fields temporarily to avoid conflicts
        migrations.RenameField(
            model_name='script',
            old_name='trigger_on_attack',
            new_name='trigger_on_attack_old',
        ),
        migrations.RenameField(
            model_name='script',
            old_name='trigger_before_attacker_turn',
            new_name='trigger_before_attacker_turn_old',
        ),
        migrations.RenameField(
            model_name='script',
            old_name='trigger_after_attacker_turn',
            new_name='trigger_after_attacker_turn_old',
        ),
        migrations.RenameField(
            model_name='script',
            old_name='trigger_before_target_turn',
            new_name='trigger_before_target_turn_old',
        ),
        migrations.RenameField(
            model_name='script',
            old_name='trigger_after_target_turn',
            new_name='trigger_after_target_turn_old',
        ),

        # 2. Add the new fields (these should already be present in the file,
        #    but ensure they are here and correct)
        migrations.AddField(
            model_name='script',
            name='trigger_duration',
            field=models.CharField(choices=[('ONCE', 'Once (Next time conditions met)'), ('PERSISTENT', 'Persistent (Until unregistered)')], default='PERSISTENT', help_text="How long does the script last? 'ONCE' triggers the next time, 'PERSISTENT' triggers repeatedly until unregistered.", max_length=10),
        ),
        migrations.AddField(
            model_name='script',
            name='trigger_when',
            field=models.CharField(choices=[('ON_USE', 'On Attack Use (Immediate, Once)'), ('BEFORE_TURN', 'Before Turn Start'), ('AFTER_TURN', 'After Turn End'), ('BEFORE_ATTACK', 'Before Attack Action'), ('AFTER_ATTACK', 'After Attack Action')], default='AFTER_TURN', help_text='When does the script trigger relative to turns or attacks?', max_length=15),
        ),
        migrations.AddField(
            model_name='script',
            name='trigger_who',
            field=models.CharField(choices=[('ME', 'Me (Original Attacker)'), ('ENEMY', 'Enemy (Original Target)'), ('ANY', 'Any Player (Current Actor)')], default='ENEMY', help_text="Which player relative to the attack use triggers the script? 'ME'=Original Attacker, 'ENEMY'=Original Target, 'ANY'=Current Actor.", max_length=10),
        ),

        # 3. Run the data migration to populate new fields from old fields
        migrations.RunPython(forwards_func, reverse_func),

        # 4. Remove the old (renamed) fields
        migrations.RemoveField(
            model_name='script',
            name='trigger_on_attack_old',
        ),
        migrations.RemoveField(
            model_name='script',
            name='trigger_before_attacker_turn_old',
        ),
        migrations.RemoveField(
            model_name='script',
            name='trigger_after_attacker_turn_old',
        ),
        migrations.RemoveField(
            model_name='script',
            name='trigger_before_target_turn_old',
        ),
        migrations.RemoveField(
            model_name='script',
            name='trigger_after_target_turn_old',
        ),
        ]
